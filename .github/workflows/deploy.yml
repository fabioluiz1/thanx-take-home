name: Deploy to AWS ECS

on:
  push:
    branches:
      - deploy
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: Deploy to ECS Fargate
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.OIDC_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.10.4

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -out=tfplan

      - name: Terraform Apply
        run: |
          cd terraform
          terraform apply -auto-approve tfplan

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push web image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
        run: |
          cd web
          echo "$SENTRY_AUTH_TOKEN" > /tmp/sentry_auth_token
          docker build \
            --build-arg VITE_SENTRY_DSN=${{ secrets.SENTRY_DSN_WEB }} \
            --build-arg VITE_GIT_SHA=${{ github.sha }} \
            --build-arg SENTRY_ORG=${{ secrets.SENTRY_ORG }} \
            --build-arg SENTRY_PROJECT=${{ secrets.SENTRY_PROJECT_WEB }} \
            --secret id=SENTRY_AUTH_TOKEN,src=/tmp/sentry_auth_token \
            -t ${{ secrets.ECR_WEB_REPOSITORY }}:$IMAGE_TAG \
            -t ${{ secrets.ECR_WEB_REPOSITORY }}:latest \
            .
          rm /tmp/sentry_auth_token
          docker push ${{ secrets.ECR_WEB_REPOSITORY }}:$IMAGE_TAG
          docker push ${{ secrets.ECR_WEB_REPOSITORY }}:latest

      - name: Build and push API image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd api
          docker build \
            -t ${{ secrets.ECR_API_REPOSITORY }}:$IMAGE_TAG \
            -t ${{ secrets.ECR_API_REPOSITORY }}:latest \
            .
          docker push ${{ secrets.ECR_API_REPOSITORY }}:$IMAGE_TAG
          docker push ${{ secrets.ECR_API_REPOSITORY }}:latest

      - name: Update API task definition with GIT_SHA
        id: update-task-def
        run: |
          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition ${{ secrets.ECS_API_TASK_DEFINITION }} \
            --query 'taskDefinition')

          # Update GIT_SHA in environment variables
          UPDATED_TASK_DEF=$(echo "$TASK_DEF" | jq --arg sha "${{ github.sha }}" '
            .containerDefinitions[0].environment = [
              .containerDefinitions[0].environment[] |
              if .name == "GIT_SHA" then .value = $sha else . end
            ]
          ')

          # Remove fields that can't be included in register-task-definition
          REGISTER_TASK_DEF=$(echo "$UPDATED_TASK_DEF" | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')

          # Register new task definition revision
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$REGISTER_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "task_definition_arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "Registered new task definition: $NEW_TASK_DEF_ARN"

      - name: Run database migrations
        run: |
          echo "Running database migrations as one-off Fargate task..."

          # Get the VPC and subnet configuration from the API service
          SERVICE_CONFIG=$(aws ecs describe-services \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --services ${{ secrets.ECS_API_SERVICE }} \
            --query 'services[0].networkConfiguration.awsvpcConfiguration')

          SUBNETS=$(echo $SERVICE_CONFIG | jq -r '.subnets | join(",")')
          SECURITY_GROUPS=$(echo $SERVICE_CONFIG | jq -r '.securityGroups | join(",")')

          # Run migrations task using the updated task definition
          TASK_ARN=$(aws ecs run-task \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --task-definition ${{ steps.update-task-def.outputs.task_definition_arn }} \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SECURITY_GROUPS],assignPublicIp=ENABLED}" \
            --overrides '{
              "containerOverrides": [{
                "name": "api",
                "command": ["bundle", "exec", "ruby", "bin/run-migrations"]
              }]
            }' \
            --query 'tasks[0].taskArn' \
            --output text)

          echo "Migration task ARN: $TASK_ARN"

          # Wait for task to complete
          echo "Waiting for migrations to complete..."
          aws ecs wait tasks-stopped \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --tasks $TASK_ARN

          # Check exit code
          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --tasks $TASK_ARN \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)

          if [ "$EXIT_CODE" != "0" ]; then
            echo "‚ùå Migrations failed with exit code: $EXIT_CODE"

            # Fetch CloudWatch logs for debugging
            echo ""
            echo "Fetching migration logs from CloudWatch..."

            # Get log configuration from task definition
            TASK_DEF=$(aws ecs describe-task-definition \
              --task-definition ${{ steps.update-task-def.outputs.task_definition_arn }} \
              --query 'taskDefinition.containerDefinitions[0].logConfiguration.options')

            LOG_GROUP=$(echo $TASK_DEF | jq -r '.["awslogs-group"]')
            LOG_PREFIX=$(echo $TASK_DEF | jq -r '.["awslogs-stream-prefix"]')
            TASK_ID=$(echo $TASK_ARN | awk -F/ '{print $NF}')
            LOG_STREAM="${LOG_PREFIX}/api/${TASK_ID}"

            echo "Log group: $LOG_GROUP"
            echo "Log stream: $LOG_STREAM"
            echo ""

            aws logs get-log-events \
              --log-group-name "$LOG_GROUP" \
              --log-stream-name "$LOG_STREAM" \
              --limit 100 \
              --query 'events[*].message' \
              --output text || echo "Could not fetch logs. Check CloudWatch at: $LOG_GROUP/$LOG_STREAM"

            exit 1
          fi

          echo "‚úÖ Migrations completed successfully"

      - name: Run database seeds
        run: |
          echo "Running database seeds as one-off Fargate task..."

          # Get the VPC and subnet configuration from the API service
          SERVICE_CONFIG=$(aws ecs describe-services \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --services ${{ secrets.ECS_API_SERVICE }} \
            --query 'services[0].networkConfiguration.awsvpcConfiguration')

          SUBNETS=$(echo $SERVICE_CONFIG | jq -r '.subnets | join(",")')
          SECURITY_GROUPS=$(echo $SERVICE_CONFIG | jq -r '.securityGroups | join(",")')

          # Run seeds task using the current task definition
          TASK_ARN=$(aws ecs run-task \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --task-definition ${{ steps.update-task-def.outputs.task_definition_arn }} \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SECURITY_GROUPS],assignPublicIp=ENABLED}" \
            --overrides '{
              "containerOverrides": [{
                "name": "api",
                "command": ["bundle", "exec", "rails", "db:seed"]
              }]
            }' \
            --query 'tasks[0].taskArn' \
            --output text)

          echo "Seed task ARN: $TASK_ARN"

          # Wait for task to complete
          echo "Waiting for seeds to complete..."
          aws ecs wait tasks-stopped \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --tasks $TASK_ARN

          # Check exit code
          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --tasks $TASK_ARN \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)

          if [ "$EXIT_CODE" != "0" ]; then
            echo "‚ùå Seeds failed with exit code: $EXIT_CODE"

            # Fetch CloudWatch logs for debugging
            echo ""
            echo "Fetching seed logs from CloudWatch..."

            # Get log configuration from task definition
            TASK_DEF=$(aws ecs describe-task-definition \
              --task-definition ${{ steps.update-task-def.outputs.task_definition_arn }} \
              --query 'taskDefinition.containerDefinitions[0].logConfiguration.options')

            LOG_GROUP=$(echo $TASK_DEF | jq -r '.["awslogs-group"]')
            LOG_PREFIX=$(echo $TASK_DEF | jq -r '.["awslogs-stream-prefix"]')
            TASK_ID=$(echo $TASK_ARN | awk -F/ '{print $NF}')
            LOG_STREAM="${LOG_PREFIX}/api/${TASK_ID}"

            echo "Log group: $LOG_GROUP"
            echo "Log stream: $LOG_STREAM"
            echo ""

            aws logs get-log-events \
              --log-group-name "$LOG_GROUP" \
              --log-stream-name "$LOG_STREAM" \
              --limit 100 \
              --query 'events[*].message' \
              --output text || echo "Could not fetch logs. Check CloudWatch at: $LOG_GROUP/$LOG_STREAM"

            exit 1
          fi

          echo "‚úÖ Seeds completed successfully"

      - name: Update web task definition with GIT_SHA
        id: update-web-task-def
        run: |
          # Get current web task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition ${{ secrets.ECS_WEB_TASK_DEFINITION }} \
            --query 'taskDefinition')

          # Update GIT_SHA in environment variables
          UPDATED_TASK_DEF=$(echo "$TASK_DEF" | jq --arg sha "${{ github.sha }}" '
            .containerDefinitions[0].environment = [
              .containerDefinitions[0].environment[] |
              if .name == "VITE_GIT_SHA" then .value = $sha else . end
            ]
          ')

          # Remove fields that can't be included in register-task-definition
          REGISTER_TASK_DEF=$(echo "$UPDATED_TASK_DEF" | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')

          # Register new task definition revision
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$REGISTER_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "task_definition_arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "Registered new web task definition: $NEW_TASK_DEF_ARN"

      - name: Update web service
        run: |
          echo "Updating web service..."
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --service ${{ secrets.ECS_WEB_SERVICE }} \
            --task-definition ${{ steps.update-web-task-def.outputs.task_definition_arn }} \
            --force-new-deployment

      - name: Update API service
        run: |
          echo "Updating API service with new task definition..."
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --service ${{ secrets.ECS_API_SERVICE }} \
            --task-definition ${{ steps.update-task-def.outputs.task_definition_arn }} \
            --force-new-deployment

      - name: Wait for services to stabilize
        timeout-minutes: 10
        run: |
          # Function to fetch and log task status
          check_service_status() {
            local service_name=$1
            local service_arn=$2

            STATUS=$(aws ecs describe-services \
              --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
              --services "$service_arn" \
              --query 'services[0]' \
              --output json)

            RUNNING=$(echo "$STATUS" | jq '.runningCount')
            DESIRED=$(echo "$STATUS" | jq '.desiredCount')

            echo "  $service_name: $RUNNING/$DESIRED running"

            # Check for crashed/stopped tasks
            TASKS=$(aws ecs list-tasks \
              --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
              --service-name "$service_arn" \
              --query 'taskArns' \
              --output json)

            TASK_COUNT=$(echo "$TASKS" | jq 'length')
            if [ "$TASK_COUNT" -gt 0 ]; then
              STOPPED_TASKS=$(aws ecs describe-tasks \
                --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
                --tasks $(echo "$TASKS" | jq -r '.[]') \
                --query 'tasks[?lastStatus==`STOPPED` || lastStatus==`DEPROVISIONING`]' \
                --output json)

              STOPPED_COUNT=$(echo "$STOPPED_TASKS" | jq 'length')
              if [ "$STOPPED_COUNT" -gt 0 ]; then
                echo "    ‚ö†Ô∏è  Found $STOPPED_COUNT stopped/crashed tasks"
                echo "$STOPPED_TASKS" | jq -r '.[] | "      - \(.taskDefinitionArn | split("/")[-1]): \(.lastStatus) (\(.stoppedReason // "no reason"))"'
                return 1
              fi
            fi
            return 0
          }

          # Function to fetch logs for a failed service
          fetch_service_logs() {
            local service_arn=$1
            local log_prefix=$2

            TASK_ARN=$(aws ecs list-tasks \
              --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
              --service-name "$service_arn" \
              --query 'taskArns[0]' \
              --output text)

            if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
              TASK_ID=$(echo $TASK_ARN | awk -F/ '{print $NF}')

              TASK_DEF=$(aws ecs describe-services \
                --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
                --services "$service_arn" \
                --query 'services[0].taskDefinition' \
                --output text)

              LOG_CONFIG=$(aws ecs describe-task-definition \
                --task-definition "$TASK_DEF" \
                --query 'taskDefinition.containerDefinitions[0].logConfiguration.options')

              LOG_GROUP=$(echo $LOG_CONFIG | jq -r '.["awslogs-group"]')
              LOG_PREFIX=$(echo $LOG_CONFIG | jq -r '.["awslogs-stream-prefix"]')
              LOG_STREAM="${LOG_PREFIX}/${log_prefix}/${TASK_ID}"

              echo "üìã Logs: $LOG_GROUP/$LOG_STREAM"
              echo ""

              aws logs get-log-events \
                --log-group-name "$LOG_GROUP" \
                --log-stream-name "$LOG_STREAM" \
                --limit 100 \
                --query 'events[*].message' \
                --output text || echo "Could not fetch logs"
            fi
          }

          echo "‚è±Ô∏è  Polling service health (max 10 minutes)..."
          MAX_ATTEMPTS=60  # 60 * 10s = 10 minutes
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo ""
            echo "Check $ATTEMPT/$MAX_ATTEMPTS:"

            # Check web service
            echo "üåê Web service:"
            if ! check_service_status "${{ secrets.ECS_WEB_SERVICE }}" "${{ secrets.ECS_WEB_SERVICE }}"; then
              echo ""
              echo "‚ùå Web service crashed"
              fetch_service_logs "${{ secrets.ECS_WEB_SERVICE }}" "web"
              exit 1
            fi

            # Check API service
            echo "üöÄ API service:"
            if ! check_service_status "${{ secrets.ECS_API_SERVICE }}" "${{ secrets.ECS_API_SERVICE }}"; then
              echo ""
              echo "‚ùå API service crashed"
              fetch_service_logs "${{ secrets.ECS_API_SERVICE }}" "api"
              exit 1
            fi

            # Check if both services are stable
            WEB_STABLE=$(aws ecs describe-services \
              --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
              --services ${{ secrets.ECS_WEB_SERVICE }} \
              --query 'length(services[0].deployments)' \
              --output text)

            API_STABLE=$(aws ecs describe-services \
              --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
              --services ${{ secrets.ECS_API_SERVICE }} \
              --query 'length(services[0].deployments)' \
              --output text)

            if [ "$WEB_STABLE" -eq 1 ] && [ "$API_STABLE" -eq 1 ]; then
              echo ""
              echo "‚úÖ Services are stable!"
              break
            fi

            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              sleep 10
            fi
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå Deployment timeout after 10 minutes"
            exit 1
          fi

          echo "‚úÖ Deployment complete!"

      - name: Get service URLs
        run: |
          echo "Fetching service public IPs..."

          # Get web task public IP
          WEB_TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --service-name ${{ secrets.ECS_WEB_SERVICE }} \
            --desired-status RUNNING \
            --query 'taskArns[0]' \
            --output text)

          if [ "$WEB_TASK_ARN" != "None" ]; then
            WEB_ENI=$(aws ecs describe-tasks \
              --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
              --tasks $WEB_TASK_ARN \
              --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
              --output text)

            WEB_IP=$(aws ec2 describe-network-interfaces \
              --network-interface-ids $WEB_ENI \
              --query 'NetworkInterfaces[0].Association.PublicIp' \
              --output text)

            echo "üåê Web URL: http://$WEB_IP"
          fi

          # Get API task public IP
          API_TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --service-name ${{ secrets.ECS_API_SERVICE }} \
            --desired-status RUNNING \
            --query 'taskArns[0]' \
            --output text)

          if [ "$API_TASK_ARN" != "None" ]; then
            API_ENI=$(aws ecs describe-tasks \
              --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
              --tasks $API_TASK_ARN \
              --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
              --output text)

            API_IP=$(aws ec2 describe-network-interfaces \
              --network-interface-ids $API_ENI \
              --query 'NetworkInterfaces[0].Association.PublicIp' \
              --output text)

            echo "üöÄ API URL: http://$API_IP:3000"
          fi

          echo ""
          echo "Note: IPs may change on service restarts. Use ECS console for current IPs."
